<pre><code class="language-fsharp">[&lt;AutoOpen&gt;]
module Fun.Blazor.Docs.Wasm.Pages.HelperFunctions.InjectDemo

open System
open FSharp.Data.Adaptive
open FSharp.Control.Reactive
open Microsoft.Extensions.DependencyInjection
open MudBlazor
open Fun.Blazor
open Fun.Blazor.Docs.Wasm.Components


type ScopedDemoService() =
    member val Count = cval 0 with get, set


//                                        Here we provide a key
//                                        If we do not provide a key, then every time we call externalDemo1 we will create a new component
//                                        And its internal state will be erased
//                                        Be careful when you provided a key: because the changes of externalX will not be used in the component, only the first one will be used
//                                        so if you have lambda like onChanged, then you may get unexpected result.
let externalDemo1 extenalX =
    html.inject (
        "externalDemo1",
        fun (hook: IComponentHook) -&gt;
            // Below code will only be executed once
            // No matter how extenalX is changed it will not trigger rerender

            let store1 = hook.UseStore 10

            hook.OnFirstAfterRender.Add(fun () -&gt;
                TimeSpan.FromSeconds 1.
                |&gt; Observable.interval
                |&gt; Observable.subscribe (fun _ -&gt; store1.Publish((+) 1))
                |&gt; hook.AddDispose
            )

            MudPaper'() {
                style { padding 10 }
                childContent [
                    MudText'.create "externalDemo1"
                    spaceV3
                    div { $"extenalX = %d{extenalX}" } // It will never change
                    spaceV2
                    html.watch (store1, (fun s1 -&gt; div.create $"Store: {s1}"))
                ]
            }
    )


let scopedDemo =
    html.inject (fun (demo1: ScopedDemoService) -&gt;
        let view (demo: ScopedDemoService) msg =
            adaptiview () {
                let! count, setCount = demo.Count.WithSetter()

                div {
                    button {
                        onclick (fun _ -&gt; setCount (count + 1))
                        "Increase"
                    }
                    div { $"{msg}: {count}" }
                }
                spaceV2
            }

        MudPaper'() {
            style { padding 10 }
            Elevation 2
            view demo1 "Count from normal scope"
            html.scoped [
                html.inject (fun (hook: IComponentHook) -&gt; view (hook.ScopedServiceProvider.GetService&lt;ScopedDemoService&gt;()) "Count from scope1")
                html.inject (fun (hook: IComponentHook) -&gt; view (hook.ScopedServiceProvider.GetService&lt;ScopedDemoService&gt;()) "Count from scope1")
            ]
            html.scoped [
                html.inject (fun (hook: IComponentHook) -&gt; view (hook.ScopedServiceProvider.GetService&lt;ScopedDemoService&gt;()) "Count from scope2")
            ]
        }
    )


// html.inject is mainly to provide the services defined in asp.net core DI
// and the IComponentHook etc.
// You can inject multiple services with tuple
let injectDemo =
    html.inject (fun (hook: IComponentHook, snackbar: ISnackbar) -&gt;
        let store = hook.UseStore 0

        hook.OnFirstAfterRender.Add(fun () -&gt;
            TimeSpan.FromSeconds 3.
            |&gt; Observable.interval
            |&gt; Observable.subscribe (fun _ -&gt;
                if store.Current &gt; 2 then
                    snackbar.Add($"Current value is {store.Current}", Severity.Info) |&gt; ignore
                store.Publish((+) 1)
            )
            |&gt; hook.AddDispose
        )

        MudPaper'() {
            style { padding 15 }
            childContent [
                spaceV3
                html.watch (
                    store,
                    fun s1 -&gt;
                        [
                            // Because we specified a key for externalDemo1 when we define it
                            // So we will not recreate a new blazor component every time and its state will not be erased
                            externalDemo1 s1
                            spaceV2
                            MudText'.create $"Store will be updated here: {s1}"
                        ]
                )
                // Because these code will only be execute one time, so below string will not change
                MudText'.create $"Store will not be updated here: {store.Current}"
                spaceV4
                MudDivider'.create ()
                spaceV4
                scopedDemo
            ]
        }
    )

</code></pre>
