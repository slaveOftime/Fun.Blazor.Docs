<h1 id="publish-trim">Publish Trim</h1>
<p>In dotnet Blazor WebAssembly, when you run <code>dotnet publish -c Release</code>, it will try to trim the IL code and reduce the size of the applicationâ€™s bundle.</p>
<p>In Fun.Blazor, for both internal or third-party libraries, you will not need to worry about this as long as those libraries work as expected with the IL linker.</p>
<p>But if you want to define your Blazor component, for example:</p>
<pre><code class="language-fsharp">// The Blazor component
type Autocomplete&lt;'T when 'T: equality&gt;() =
    inherit MudBaseInput&lt;'T option&gt;()    
    
    [&lt;Parameter&gt;]
    member val Clearable = true with get, set

    ...


// The DSL for Fun.Blazor 
type Autocomplete'&lt;'T when 'T : equality&gt; [&lt;DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof&lt;Autocomplete&lt;_&gt;&gt;)&gt;] () =
    inherit DslInternals.MudBaseInputBuilder&lt;Autocomplete&lt;'T&gt;, 'T option&gt;()

    [&lt;CustomOperation(&quot;Clearable&quot;)&gt;]
    member inline _.Clearable([&lt;InlineIfLambda&gt;] render: AttrRenderFragment, x: bool) = render ==&gt; (&quot;Clearable&quot; =&gt; x)

    ...
</code></pre>
<p>You will need to add <code>[&lt;DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof&lt;Autocomplete&lt;_&gt;&gt;)&gt;]</code> to the default constructor. The reason is in Blazor, it uses a string to find the key to set its parameters. So the IL linker will trim all of its content because only the type is referenced, but nothing is directly consumed anywhere.</p>
<p>Also for things like <code>[&lt; Inject&gt;]</code>, the set method will be trimmed because the set will never be consumed directly.</p>
<p>So to simplify the trim logic, I use <code>DynamicallyAccessedMemberTypes.All</code> to try to keep all of the logic for the type Autocomplete.</p>
<p>In the <code>Fun.Blazor.Cli</code>, it will automatically add those attributes to help the IL linker to trim things correctly. If you are using MudBlazor which starts from 6.0.10, it supports trim by default now, and you can use the latest version of the cli to regenerate the bindings after you have upgraded its version.</p>
<h2 id="manually-control-link-behavior-for-assemblies">Manually Control Link Behavior for Assemblies</h2>
<p>dotnet core supports adding some configuration in the root project file to set the trim behavior for assemblies. Below is a demo configuration which is used in the Fun.Blazor.Docs.Wasm.fsproj file. It means I want to trim FSharp.Data and FSharp.Control.Reactive with the link mode because by default those libraries are not set to trim mode.</p>
<p>But you will need to be careful as it may cause issues. So please verify the published application carefully.</p>
<pre><code class="language-xml">&lt;Target Name=&quot;ConfigureTrimming&quot; BeforeTargets=&quot;PrepareForILLink&quot;&gt;
    &lt;ItemGroup&gt;
        &lt;ManagedAssemblyToLink Condition=&quot;'%(Filename)' == 'FSharp.Data'&quot;&gt;
            &lt;TrimMode&gt;link&lt;/TrimMode&gt;
            &lt;IsTrimmable&gt;true&lt;/IsTrimmable&gt;
        &lt;/ManagedAssemblyToLink&gt;
        &lt;ManagedAssemblyToLink Condition=&quot;'%(Filename)' == 'FSharp.Control.Reactive'&quot;&gt;
            &lt;TrimMode&gt;link&lt;/TrimMode&gt;
            &lt;IsTrimmable&gt;true&lt;/IsTrimmable&gt;
        &lt;/ManagedAssemblyToLink&gt;
    &lt;/ItemGroup&gt;
&lt;/Target&gt;
</code></pre>
