<h1 id="section">打包发布</h1>
<p>在 .NET Blazor WebAssembly 中，当你运行 <code>dotnet publish -c Release</code> 命令时，它会尝试裁剪 IL 代码并减少应用程序包的大小。</p>
<p>在 Fun.Blazor 中，无论是内部还是第三方库，只要这些库与 IL 编译器一起按预期工作，您就不需要担心这个问题。</p>
<p>但是，如果您想定义自己的 Blazor 组件，例如：</p>
<pre><code class="language-fsharp">// The Blazor component
type Autocomplete&lt;'T when 'T: equality&gt;() =
    inherit MudBaseInput&lt;'T option&gt;()    
    
    [&lt;Parameter&gt;]
    member val Clearable = true with get, set

    ...


// The DSL for Fun.Blazor 
type Autocomplete'&lt;'T when 'T : equality&gt; [&lt;DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof&lt;Autocomplete&lt;_&gt;&gt;)&gt;] () =
    inherit DslInternals.MudBaseInputBuilder&lt;Autocomplete&lt;'T&gt;, 'T option&gt;()

    [&lt;CustomOperation(&quot;Clearable&quot;)&gt;]
    member inline _.Clearable([&lt;InlineIfLambda&gt;] render: AttrRenderFragment, x: bool) = render ==&gt; (&quot;Clearable&quot; =&gt; x)

    ...
</code></pre>
<p>你需要为默认构造函数添加 <code>[&lt;DynamicDependency(DynamicallyAccessedMemberTypes.All, typeof&lt;Autocomplete&lt;_&gt;&gt;)&gt;]</code>。这是因为 Blazor 使用字符串查找并设置其参数。因此，IL 链接器将删除所有的内容，因为只有引用了类型，但没有在任何地方直接使用。</p>
<p>对于 <code>[&lt; Inject&gt;]</code> 等类似的东西，由于 set 方法永远不会直接被使用，因此 set 方法将被删除。</p>
<p>因此，为了简化修剪逻辑，我使用了 <code>DynamicallyAccessedMemberTypes.All</code> 来尝试保留类型 Autocomplete 的所有逻辑。</p>
<p>在 <code>Fun.Blazor.Cli</code> 中，它将自动添加这些属性，以帮助 IL 链接器正确修剪。如果您使用的是 MudBlazor 6.0.10 及以上版本，它现在默认支持修剪，您可以使用最新版本的 cli，在升级其版本后重新生成绑定。</p>
<h2 id="section-1">手动控制程序集的链接行为</h2>
<p>dotnet core 支持在根项目文件中添加一些配置来设置程序集的修剪行为。下面是 Fun.Blazor.Docs.Wasm.fsproj 文件中使用的演示配置。它意味着我想用链接模式修剪 FSharp.Data 和 FSharp.Control.Reactive，因为这些库默认情况下不设置修剪模式。</p>
<p>但是你需要小心，因为这可能会导致运行时错误。因此，请仔细验证已发布的应用程序。</p>
<pre><code class="language-xml">&lt;Target Name=&quot;ConfigureTrimming&quot; BeforeTargets=&quot;PrepareForILLink&quot;&gt;
    &lt;ItemGroup&gt;
        &lt;ManagedAssemblyToLink Condition=&quot;'%(Filename)' == 'FSharp.Data'&quot;&gt;
            &lt;TrimMode&gt;link&lt;/TrimMode&gt;
            &lt;IsTrimmable&gt;true&lt;/IsTrimmable&gt;
        &lt;/ManagedAssemblyToLink&gt;
        &lt;ManagedAssemblyToLink Condition=&quot;'%(Filename)' == 'FSharp.Control.Reactive'&quot;&gt;
            &lt;TrimMode&gt;link&lt;/TrimMode&gt;
            &lt;IsTrimmable&gt;true&lt;/IsTrimmable&gt;
        &lt;/ManagedAssemblyToLink&gt;
    &lt;/ItemGroup&gt;
&lt;/Target&gt;
</code></pre>
