<h2 id="section">这是如何工作的？</h2>
<p>Fun.Blazor 为 Blazor 提供了一系列委托进行处理。例如，当您编写：</p>
<pre><code class="language-fsharp">let demo =
    div {
        class' &quot;cool&quot;
    }
</code></pre>
<p>这段代码本质上变成了：</p>
<pre><code class="language-fsharp">let demo =
    NodeRenderFragment(fun comp builder index -&gt;  // 委托
        builder.OpenElement(index, &quot;div&quot;)
        bulder.AddAttribute(index + 1, &quot;class&quot;, &quot;cool&quot;)
        builer.CloseElement()
        index + 2
    )

type NodeRenderFragment = delegate of root: IComponent * builder: RenderTreeBuilder * sequence: int -&gt; int
</code></pre>
<p>本质上，你已经创建了一个委托，该委托将传递给一个组件，该组件将管理 DOM 树的渲染或构建。这种方法类似于 Razor 引擎在 C# 世界中生成的内容。</p>
<p>可以使用 <code>adaptiview</code>、<code>html.inject</code> 等创建组件。这些组件是从 <code>ComponentBase</code> 继承的普通 Blazor 组件。</p>
<h2 id="fun.blazor">在使用 Fun.Blazor 之前要考虑以下几点：</h2>
<ol>
<li><p>F# 编译器在某些大型计算表达式 (CE) 的智能提示方面存在性能问题。最好减小单个 CE 块或文件，或使用 <code>seq</code>、<code>list</code> 或 <code>array</code> 与 <code>childContent</code> 以获得更好的智能提示效果：</p>
<p>There are some tests in <a href="https://github.com/albertwoo/CEPerfDemo">here</a>, in summary, below are some recommend ways for better build time performance (but it can reduce runtime performance because we cannot inline and need to allocate memory on head for creating array or list)</p>
<ul>
<li><p>The best result is <strong>list-with-local-vars</strong> for multiple child items</p>
<pre><code class="language-fsharp">let demo1 = div {
    class' &quot;font-bold&quot;
    &quot;demo1&quot;
}

let demo2 = div {
    class' &quot;font-bold&quot;
    &quot;demo2&quot;
}

let comp = div {
    style { color &quot;red&quot; }
    childContent [| // 👌✅
        demo1
        demo2
    |]
}
</code></pre>
</li>
<li><p><strong>nested-one</strong> is ok</p>
<pre><code class="language-fsharp">let comp = div {
    class' &quot;font-bold&quot;
    div { // 👌✅
        class' &quot;font-bold&quot;
        div { &quot;demo1&quot; }
    }
}
</code></pre>
</li>
<li><p><strong>nested-one-one</strong> is not ok (bad for build perf)</p>
<pre><code class="language-fsharp">let comp = div {
    class' &quot;font-bold&quot;
    div {
        class' &quot;font-bold&quot;
        div { // ⛔🙅
            class' &quot;font-bold&quot;
            div { &quot;demo1&quot; }
        }
    }
}
</code></pre>
</li>
<li><p>inline local vars is not ok (bad for build perf)</p>
<pre><code class="language-fsharp">let comp = div {
    class' &quot;font-bold&quot;
    let temp = div { // ⛔🙅
        class' &quot;font-bold&quot;
        &quot;demo1&quot;
    }
    temp
}
</code></pre>
</li>
</ul>
</li>
<li><p>热重载</p>
<p>默认的模板已提供有限的热重载支持。 在过多的文件情况下会减慢热重载过程，因此为了取得最佳效果，应在想启用热重载的文件顶部添加 <code>// hot-reload</code> 。更多信息，请参见 <a href="https://www.slaveoftime.fun/blog/d959e36a-f4fe-4a10-88af-5e738633db0f?title=%20Hot-reload%20in%20Fun.Blazor">Fun.Blazor 热重载</a> 博客文章或 <a href="https://slaveoftime.github.io/Fun.Blazor.Docs/?doc=/Hot%20Reload">文档</a>.</p>
</li>
<li><p>对于组件元素中的属性和子元素，最好按以下方式排列：</p>
<pre><code class="language-fsharp">div {
    attributes ...
    ref (fun x -&gt; ()) // ✅
    childContent [ ... ]
}
</code></pre>
<p>或者：</p>
<pre><code class="language-fsharp">div {
    attributes ...
    ref (fun x -&gt; ()) // ✅
    div { 1 }
    div { 1 }
    // ...
}
</code></pre>
</li>
</ol>
<h2 id="section-1">基准测试</h2>
<p>BenchmarkDotNet v0.13.12, Windows 11 (10.0.22631.3007/23H2/2023Update/SunValley3)
12th Gen Intel Core i7-12700H, 1 CPU, 20 logical and 14 physical cores
.NET SDK 8.0.100
[Host]     : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2 DEBUG
DefaultJob : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">RatioSD</th>
<th style="text-align: right;">Gen0</th>
<th style="text-align: right;">Allocated</th>
<th style="text-align: right;">Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>RenderWithRazorCSharp</td>
<td style="text-align: right;">234.1 ns</td>
<td style="text-align: right;">3.59 ns</td>
<td style="text-align: right;">3.36 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.00</td>
<td style="text-align: right;">0.0298</td>
<td style="text-align: right;">376 B</td>
<td style="text-align: right;">1.00</td>
</tr>
<tr>
<td>RenderWithFunBlazorInlineCE</td>
<td style="text-align: right;">363.5 ns</td>
<td style="text-align: right;">4.14 ns</td>
<td style="text-align: right;">3.67 ns</td>
<td style="text-align: right;">1.55</td>
<td style="text-align: right;">0.03</td>
<td style="text-align: right;">0.0443</td>
<td style="text-align: right;">560 B</td>
<td style="text-align: right;">1.49</td>
</tr>
<tr>
<td>RenderWithFunBlazorArray</td>
<td style="text-align: right;">499.0 ns</td>
<td style="text-align: right;">9.82 ns</td>
<td style="text-align: right;">10.91 ns</td>
<td style="text-align: right;">2.14</td>
<td style="text-align: right;">0.05</td>
<td style="text-align: right;">0.1154</td>
<td style="text-align: right;">1448 B</td>
<td style="text-align: right;">3.85</td>
</tr>
<tr>
<td>RenderWithBolero</td>
<td style="text-align: right;">507.9 ns</td>
<td style="text-align: right;">9.74 ns</td>
<td style="text-align: right;">11.21 ns</td>
<td style="text-align: right;">2.17</td>
<td style="text-align: right;">0.07</td>
<td style="text-align: right;">0.1173</td>
<td style="text-align: right;">1480 B</td>
<td style="text-align: right;">3.94</td>
</tr>
</tbody>
</table>
