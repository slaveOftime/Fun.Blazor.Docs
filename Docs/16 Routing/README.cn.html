<h1 id="section">路由</h1>
<h2 id="blazor">blazor 官方风格</h2>
<pre><code class="language-fsharp">type MainLayout() as this =
    inherit LayoutComponentBase()

    let content = div {
        nav {
            // your nav code
        }
        main { this.Body }
    }

    override _.BuildRenderTree(builder) = content.Invoke(this, builder, 0) |&gt; ignore


type Routes() =
    inherit FunComponent()

    override _.Render() = Router'() {
        AppAssembly(Assembly.GetExecutingAssembly())
        Found(fun routeData -&gt; RouteView'() {
            RouteData routeData
            DefaultLayout typeof&lt;MainLayout&gt;
        })
    }
</code></pre>
<p>所有的 page 入口则应该也用 class component：</p>
<pre><code class="language-fsharp">[&lt;Route &quot;/counter&quot;&gt;]
[&lt;RenderModeInteractiveServer&gt;]
type Counter() =
    inherit FunComponent()

    let mutable count = 0

    override _.Render() = fragment {
        PageTitle'() { &quot;Counter&quot; }
        p { $&quot;Current count: {count}&quot; }
        button {
            on.click (fun _ -&gt; count &lt;- count + 1)
            &quot;Click me&quot;
        }
    }
</code></pre>
<h2 id="section-1">函数式风格</h2>
<p>在 Fun.Blazor 中，我们内置了路由支持，但你也可以使用自己的路由。内置路由非常简单，受 <a href="https://github.com/giraffe-fsharp/Giraffe">Giraffe</a> 的启发。</p>
<p>在底层，我们会创建一个组件来监听路由变化并内部使用自适应模型，因此如果实际路径未更改，则 UI 不会重新渲染。</p>
<p>我们还支持一些辅助函数，如 <strong>routeCi &quot;/demo&quot; demoView</strong>。它只是一个函数：<code>UrlString -&gt; 'T option</code>。因此，如果返回值有内容，则会返回该内容。它可以只是一个视图片段或其他任何东西。</p>
<p>以下面的代码为例：</p>
