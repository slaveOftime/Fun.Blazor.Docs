<h2 id="extend-hooks">Extend Hooks</h2>
<p>If you do not care about unit testing, you can extend your own functionality like this. But in this way, it is not easy to mock the extension methods.</p>
<pre><code class="language-fsharp">type IComponentHook with
    member hook.DataCanBeShared =
        let store = hook.ServiceProvider.GetService&lt;IShareStore&gt;()
        store.CreateCVal(nameof hook.DataCanBeShared, LoadingState&lt;...&gt;.NotStartYet)

    member hook.LoadDataAfterRender() =
        hook.AddFirstAfterRenderTask(fun () -&gt;
            task {
                hook.DataCanBeShared.Publish LoadingState.start
                let! result = ... call some API
                hook.DataCanBeShared.Publish (LoadingState.Loaded data)
            }
        )
</code></pre>
<p>If you want to make your component unit testing friendly, you will need to do more stuff:</p>
<ol>
<li><p>Define an interface.</p>
<pre><code class="language-fsharp">type IMyCompHook =
    abstract member DataCanBeShared: ...
    abstract member LoadDataAfterRender: ...
</code></pre>
</li>
<li><p>Implement it.</p>
<pre><code class="language-fsharp">type MyCompHook (hook: IComponentHook) =
    interface IMyCompHook with
        ...
</code></pre>
</li>
<li><p>Add it to the DI container at the program start.</p>
<pre><code class="language-fsharp">// Under the hood, it just registers a singleton factory function for the consumer to use.
services.AddHookService&lt;IMyCompHook&gt;(MyCompHook)
</code></pre>
</li>
<li><p>Use it in your component.</p>
<pre><code class="language-fsharp">let myComp =
    html.inject (fun (hook: IComponentHook) -&gt;
        // Every time you consume this, it will create a new instance for you.
        let myCompHook = hook.GetHookService&lt;IMyCompHook&gt;()
        ...
    )
</code></pre>
</li>
<li><p>Finally, when you do your testing, you can use bUnit to mock the interface as usual.</p>
</li>
</ol>
