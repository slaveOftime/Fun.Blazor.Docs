<h1 id="section">自定义元素</h1>
<p>您需要安装 <strong>Fun.Blazor.CustomElements</strong>。</p>
<p>我创建了这个功能，因为在某些用例中，我只想让 ASP.NET Core 使用 Fun.Blazor 来预渲染静态内容，而不连接到 Blazor 服务器。但是对于某些页面或组件，我希望临时连接到 Blazor 服务器。因此，我仍然可以使用 Blazor 并使用单个 WebSocket 隐藏后端 API 进行交互。</p>
<p>它是由 <strong>Microsoft.AspNetCore.Components.CustomElements</strong> 驱动的，这在 .NET 7 中得到了官方支持。</p>
<h2 id="section-1">如何使用</h2>
<p>注册组件：</p>
<pre><code class="language-fsharp">...
services.AddServerSideBlazor(fun options -&gt; options.RootComponents.RegisterCustomElementForFunBlazor(Assembly.GetExecutingAssembly()))
...
</code></pre>
<p>在 html head 中配置帮助脚本：</p>
<pre><code class="language-fsharp">html {
    head {
        ...
        CustomElement.lazyBlazorJs ()
    }
    body {
        ...
    }
}
</code></pre>
<p>定义你的组件：</p>
<pre><code class="language-fsharp">
[&lt;FunBlazorCustomElement&gt;]
type PostLikesSurvey() =
    inherit FunComponent()

    [&lt;Parameter&gt;]
    member val post_id = &quot;&quot; with get, set

    override this.Render() = fragment {
        ...
    }
</code></pre>
<p>使用你的组件：</p>
<pre><code class="language-fsharp">html.customElement (
    ComponentAttrBuilder&lt;PostLikesSurvey&gt;().Add((fun x -&gt; x.post_id), post.Id.ToString()),
    renderAfter = RenderAfter.InViewport
)
</code></pre>
<h2 id="section-2">示例</h2>
<p>下面有一些计数器，但它们共享同一个 <code>IShareStore</code>。所以在 Blazor 服务器模式下，当您单击一个按钮时，另一个按钮也会自动增加，这意味着它们共享同一个 WebSocket 连接。</p>
