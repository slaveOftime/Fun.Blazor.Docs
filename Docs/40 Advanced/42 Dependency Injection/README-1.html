<p>Normally you should consider using <strong>html.injectWithNoKey</strong>, because it performance better, but sometimes you may have below situation:</p>
<pre><code class="language-fsharp">let comp1 = html.injectWithNoKey(...)
let comp2 = html.injectWithNoKey(...)

let comp =
    div {
        if some conditions then comp1
        else comp2
    }
</code></pre>
<p>In above situation you will get unexpected behavior, because blazor will consider <strong>comp1</strong> and <strong>comp2</strong> as the same component, and will not re-create related component for you. and the consumer <strong>comp</strong> may not know if comp1 or comp2 has specified key or not, even the key is specified, the key maybe the same.</p>
<p>So the nicer api is give to the inject with ramdom key which is <strong>html.inject</strong>. But as it will re-create component everytime when you call html.inject, so it also may lead other situation, like infinite re-render. But do not be afraid, it is rare, I only face this issue once when using <strong>MudBlazor</strong>'s <strong>MudLayout</strong> and <strong>MudDrawer</strong> together, for this case, I use <strong>html.injectWithNoKey</strong> to solve it. I can also use <strong>html.inject (key, ...)</strong> to solve it too.</p>
<p>If you don't like the pattern like <strong>html.inject/adaptiview</strong>, you can just create your component inherit <strong>FunComponent</strong> and get the benefit of the DOM DSL and third-party DSL support like MudBlazor from Fun.Blazor.</p>
<p><strong>Dependency injection (DI)</strong> is essential in many software applications. ASP.NET Core has built-in support for it, and it is also helpful for testing and cross-concern solutions. Not only services but also UI components can be powered by <strong>dependency injection</strong>.</p>
<p><strong>html.inject</strong> is used to inject the service you defined in the DI container.</p>
