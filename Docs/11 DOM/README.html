<h1 id="dom">DOM</h1>
<p>The most important thing for <strong>Fun.Blazor</strong> is the DSL to build the DOM.
Even before V2, computation expression style DSL is already supported.</p>
<p>It is very easy to build and compose dom:</p>
<pre><code class="language-fsharp">
let fragment1 = div { &quot;F=ma&quot; }

let composed =
    div {
        style { height 500 }
        p { &quot;This is the way!&quot; }
        if conditionIsTrue then
            fragment1
            p { &quot;E = MCC&quot; }
    }
</code></pre>
<p>Also you can build a shared attributes/style fragment to compose:</p>
<pre><code class="language-fsharp">let commonStyle =
    css {
        cursorPointer
        color &quot;green&quot;
    }

let commonAttr =
    domAttr {
        data 123
        asAttrRenderFragment
    }

let sharedButtonAttrs =
    button {
        style {
            commonStyle
            // css priority/override is controlled by browser. 
            // For &quot;color&quot;, &quot;red&quot; will be used.
            color &quot;red&quot; 
        }
        data 456
        // attribute priority is controlled by blazor core. 
        // Currently only the first added attribute will be used when you are trying to add same attribute. 
        // That is why I put commonAttr lower than &quot;data 456&quot;, 
        // so the 456 will be used even in commonAttr &quot;data&quot; is 123.
        commonAttr
        asAttrRenderFragment // Here is the thing to make the magic happen
    }

let demo =
    div {
        p { &quot;Below we will have a cool button&quot; }
        button {
            onclick ignore
            sharedButtonAttrs
            &quot;Cool&quot;
        }
    }    
</code></pre>
<p>You can also create extension operation method to create something to reuse. And with this way, it is type safer because it attach to a specific type. It if better to use it for global sharing stuff. As for <strong>asAttrRenderFragment</strong>, it is recommend to use it only locally, because what it generate is just <strong>AttrRenderFragment</strong> which can be combined any where.</p>
<p>For css you can do:</p>
<pre><code class="language-fsharp">type StyleBuilder with

    [&lt;CustomOperation(&quot;stack&quot;)&gt;]
    member inline _.stack([&lt;InlineIfLambda&gt;] comb: CombineKeyValue) =
        comb
        &amp;&amp;&amp; css {
            height &quot;100%&quot;
            displayFlex
            flexDirectionColumn
            alignItemsStretch
            overflowHidden
        }

    [&lt;CustomOperation(&quot;strench&quot;)&gt;]
    member inline _.strench([&lt;InlineIfLambda&gt;] comb: CombineKeyValue) =
        comb
        &amp;&amp;&amp; css {
            flex 1
            height &quot;100%&quot;
            width &quot;100%&quot;
            positionRelative
            overflowXHidden
            overflowYAuto
        }


let demo =
    div {
        style { stack; backgroundColor &quot;blue&quot; }
        div { &quot;header&quot; }
        div {
            style { strench; backgroundColor &quot;green&quot; }
        }
    }        
</code></pre>
<p>For DOM element/component, you can do:</p>
<pre><code class="language-fsharp">open Fun.Blazor
open Fun.Blazor.Operators
open MudBlazor

type MudTable'&lt;'T&gt; with

    [&lt;CustomOperation(&quot;HeaderAndRow&quot;)&gt;]
    member this.HeaderAndRow(render: AttrRenderFragment, mappers: (NodeRenderFragment * ('T -&gt; NodeRenderFragment)) seq) =
        let headers = mappers |&gt; Seq.map fst
        let render = this.HeaderContent(render, html.fragment headers)
        this.RowTemplate(render, (fun row -&gt; html.inject (row, (fun () -&gt; mappers |&gt; Seq.map (snd &gt;&gt; fun fn -&gt; fn row) |&gt; html.fragment))))

    [&lt;CustomOperation(&quot;withDefaultSettings&quot;)&gt;]
    member inline _.withDefaultSettings([&lt;InlineIfLambda&gt;] render: AttrRenderFragment) =
        render
        ==&gt; MudTable'() {
            Hover true
            FixedHeader true
            HorizontalScrollbar true
            Breakpoint Breakpoint.None
            asAttrRenderFragment // with this feature we can have a better coding experience
        }


let demo =
    MudTable'() {
        Height &quot;100%&quot;
        Items items
        HeaderAndRow [
            MudTh'() { &quot;Name&quot; },
            fun item -&gt; MudTd'() { item.Name }

            MudTh'() { &quot;Age&quot; },
            fun item -&gt; MudTd'() { item.Age }
        ]
        withDefaultSettings
    }
</code></pre>
