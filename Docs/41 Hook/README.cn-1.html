<h2 id="hooks">扩展 Hooks</h2>
<p>如果您不关心单元测试，可以像这样扩展您自己的功能。但用这种方式，很难 Mock 扩展方法。</p>
<pre><code class="language-fsharp">type IComponentHook with
    member hook.DataCanBeShared =
        let store = hook.ServiceProvider.GetService&lt;IShareStore&gt;()
        store.CreateCVal(nameof hook.DataCanBeShared, LoadingState&lt;...&gt;.NotStartYet)

    member hook.LoadDataAfterRender() =
        hook.AddFirstAfterRenderTask(fun () -&gt;
            task {
                hook.DataCanBeShared.Publish LoadingState.start
                let! result = ... call some API
                hook.DataCanBeShared.Publish (LoadingState.Loaded data)
            }
        )
</code></pre>
<p>如果你想让你的组件单元测试友好，你需要进行一些额外的工作：</p>
<ol>
<li><p>定义一个接口。</p>
<pre><code class="language-fsharp">type IMyCompHook =
    abstract member DataCanBeShared: ...
    abstract member LoadDataAfterRender: ...
</code></pre>
</li>
<li><p>实现它。</p>
<pre><code class="language-fsharp">type MyCompHook (hook: IComponentHook) =
    interface IMyCompHook with
        ...
</code></pre>
</li>
<li><p>在程序启动时将其添加到 DI 容器中。</p>
<pre><code class="language-fsharp">// 其中使用 `services.AddHookService&lt;IMyCompHook&gt;(MyCompHook)` 方法注册一个单例工厂函数，以供消费者使用。
services.AddHookService&lt;IMyCompHook&gt;(MyCompHook)
</code></pre>
</li>
<li><p>在组件中使用它。</p>
<pre><code class="language-fsharp">let myComp =
    html.comp (fun (hook: IComponentHook) -&gt;
        // 每次消费时都会创建一个新的实例
        let myCompHook = hook.GetHookService&lt;IMyCompHook&gt;()
        ...
    )
</code></pre>
</li>
<li><p>最后，在测试时，可以像往常一样使用 bUnit 来 mock 这个接口。</p>
</li>
</ol>
